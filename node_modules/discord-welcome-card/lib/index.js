"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Text = exports.themes = exports.goodbyeImage = exports.welcomeImage = exports.drawCard = void 0;
const canvas_1 = require("canvas");
const lib_1 = require("./lib");
require("@discord-card/core"); //To polyfill canvas class and load font
function drawCard(options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u;
    return __awaiter(this, void 0, void 0, function* () {
        const w = 700, h = 250;
        const canvas = (0, canvas_1.createCanvas)(w, h);
        const ctx = canvas.getContext('2d');
        ctx.w = ctx.width = w;
        ctx.h = ctx.height = h;
        //@ts-ignore
        let theme;
        let background;
        (_a = options.border) !== null && _a !== void 0 ? _a : (options.border = true);
        (_b = options.rounded) !== null && _b !== void 0 ? _b : (options.rounded = true);
        //Parsing the Theme
        if (typeof ((_c = options.theme) !== null && _c !== void 0 ? _c : 'code') === 'string') {
            theme = lib_1.themes[(_d = options.theme) !== null && _d !== void 0 ? _d : 'code'];
            if (!theme)
                throw new Error('Invalid theme, use: ' + Object.keys(lib_1.themes).join(' | '));
            background = yield (0, canvas_1.loadImage)(theme.image);
        }
        else
            throw new Error('Invalid theme, use: ' + Object.keys(lib_1.themes).join(' | '));
        if (options.background)
            background = yield (0, lib_1.toImage)(options.background, 'Background');
        ctx.theme = theme;
        /** Border width */
        const b = 10; //Border
        //Background
        (0, lib_1.snap)(canvas);
        if (options.rounded)
            ctx.roundRect(0, 0, w, h, h / 15);
        else
            ctx.rect(0, 0, w, h);
        ctx.clip();
        if (options.border) {
            ctx.drawImage(background, 0, 0, w, h);
            ctx.globalAlpha = 0.3;
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, w, h);
            ctx.globalAlpha = 1;
            ctx.blur(3);
        }
        (0, lib_1.snap)(canvas);
        //Rounded Edges
        if (options.border) {
            if (options.rounded) {
                ctx.roundRect(b, b, w - 2 * b, h - 2 * b, h / 20);
            }
            else {
                ctx.rect(b, b, w - 2 * b, h - 2 * b);
            }
            ctx.clip();
        }
        else {
            if (options.rounded)
                ctx.roundRect(0, 0, w, h, h / 15).clip();
            else
                ctx.rect(0, 0, w, h);
        }
        var temp = background;
        if (options.blur) {
            var blur = (0, canvas_1.createCanvas)(w, h), blur_ctx = blur.getContext('2d');
            blur_ctx.drawImage(background, 0, 0, w, h);
            if (typeof options.blur === 'boolean')
                blur_ctx.blur(3);
            else
                blur_ctx.blur(options.blur);
            temp = blur;
        }
        if (options.border)
            ctx.drawImage(temp, b, b, w - b * 2, h - b * 2);
        else
            ctx.drawImage(temp, 0, 0, w, h);
        (0, lib_1.snap)(canvas);
        //Setting Styles
        ctx.fillStyle = ((_f = (_e = options.text) === null || _e === void 0 ? void 0 : _e.color) !== null && _f !== void 0 ? _f : theme.color).toString(ctx);
        //ctx.strokeStyle = theme.color.toString(ctx);
        ctx.font = '30px ' + ((_j = (_h = (_g = options.text) === null || _g === void 0 ? void 0 : _g.font) !== null && _h !== void 0 ? _h : theme.font) !== null && _j !== void 0 ? _j : 'SegoeUI') + ', SegoeUI, SegoeUIEmoji';
        //Drawing
        //Title
        if ((_k = options.text) === null || _k === void 0 ? void 0 : _k.title) {
            const txt = options.text.title;
            if (typeof txt === 'string') {
                ctx.changeFontSize('30px').fillText(txt, ctx.width / 2.7, ctx.height / 3.5);
            }
            else
                txt.draw(ctx); //instanceof Text
        }
        //Text
        if ((_l = options.text) === null || _l === void 0 ? void 0 : _l.text) {
            const txt = options.text.text;
            if (typeof txt === 'string') {
                ctx.changeFontSize((0, lib_1.getFontSize)(txt) + 'px').fillText(txt, ctx.width / 2.7, ctx.height / 1.8);
            }
            else
                txt.draw(ctx); //instanceof Text
        }
        //Subtitle
        if ((_m = options.text) === null || _m === void 0 ? void 0 : _m.subtitle) {
            const txt = options.text.subtitle;
            if (typeof txt === 'string') {
                ctx.changeFontSize('25px').fillText(txt, ctx.width / 2.7, ctx.height / 1.3);
            }
            else
                txt.draw(ctx); //instanceof Text
        }
        //Avatar Image
        const radius = (h / 2) * ((_p = (_o = options.avatar) === null || _o === void 0 ? void 0 : _o.imageRadius) !== null && _p !== void 0 ? _p : 0.8);
        function applyShape(offset = 0) {
            var _a;
            if ((_a = options.avatar) === null || _a === void 0 ? void 0 : _a.borderRadius) {
                ctx.roundRect(h / 2 - radius - offset, h / 2 - radius - offset, radius * 2 + 2 * offset, radius * 2 + 2 * offset, options.avatar.borderRadius * radius);
            }
            else {
                ctx.beginPath();
                ctx.arc(h / 2, h / 2, radius + offset, 0, Math.PI * 2, true);
                ctx.closePath();
            }
            return ctx;
        }
        const { avatar } = options;
        if (avatar) {
            const { image: avatarImage, outlineWidth, outlineColor } = avatar;
            if (avatarImage) {
                applyShape(-5).clip();
                ctx.drawImage(yield (0, lib_1.toImage)(avatarImage), h / 2 - radius + ((_q = avatar.outlineWidth) !== null && _q !== void 0 ? _q : 0), //x
                h / 2 - radius + ((_r = avatar.outlineWidth) !== null && _r !== void 0 ? _r : 0), //y
                radius * 2 - ((_s = avatar.outlineWidth) !== null && _s !== void 0 ? _s : 0) * 2, //width
                radius * 2 - ((_t = avatar.outlineWidth) !== null && _t !== void 0 ? _t : 0) * 2 //height
                );
            }
            if (outlineWidth) {
                applyShape(-outlineWidth / 2);
                let r = radius;
                ctx.lineWidth = outlineWidth;
                ctx.strokeStyle = ((_u = outlineColor !== null && outlineColor !== void 0 ? outlineColor : theme.color) !== null && _u !== void 0 ? _u : '#fff').toString(ctx, ctx.h / 2 - r, h / 2 - r, h / 2 + r, h / 2 + r);
                ctx.stroke();
            }
        }
        (0, lib_1.snap)(canvas);
        return canvas.toBuffer('image/png');
    });
}
exports.drawCard = drawCard;
function welcomeImage(member, options = {}) {
    var _a, _b, _c, _d, _e, _f;
    var _g, _h, _j, _k;
    return __awaiter(this, void 0, void 0, function* () {
        const opts = Object.assign({}, options);
        (_a = opts.text) !== null && _a !== void 0 ? _a : (opts.text = {});
        (_b = opts.avatar) !== null && _b !== void 0 ? _b : (opts.avatar = {});
        (_c = (_g = opts.text).title) !== null && _c !== void 0 ? _c : (_g.title = `Welcome to this server,`);
        (_d = (_h = opts.text).text) !== null && _d !== void 0 ? _d : (_h.text = `${member.user.tag}!`);
        (_e = (_j = opts.text).subtitle) !== null && _e !== void 0 ? _e : (_j.subtitle = `MemberCount: ${member.guild.memberCount}`);
        (_f = (_k = opts.avatar).image) !== null && _f !== void 0 ? _f : (_k.image = yield (0, canvas_1.loadImage)(member.user.displayAvatarURL({ format: 'png' })));
        return yield drawCard(opts);
    });
}
exports.welcomeImage = welcomeImage;
function goodbyeImage(member, options = {}) {
    var _a, _b, _c, _d, _e;
    var _f, _g, _h;
    return __awaiter(this, void 0, void 0, function* () {
        const opts = Object.assign({}, options);
        (_a = opts.text) !== null && _a !== void 0 ? _a : (opts.text = {});
        (_b = opts.avatar) !== null && _b !== void 0 ? _b : (opts.avatar = {});
        (_c = (_f = opts.text).title) !== null && _c !== void 0 ? _c : (_f.title = `Goodbye,`);
        (_d = (_g = opts.text).text) !== null && _d !== void 0 ? _d : (_g.text = `${member.user.tag}!`);
        (_e = (_h = opts.avatar).image) !== null && _e !== void 0 ? _e : (_h.image = yield (0, canvas_1.loadImage)(member.user.displayAvatarURL({ format: 'png' })));
        return yield drawCard(opts);
    });
}
exports.goodbyeImage = goodbyeImage;
var lib_2 = require("./lib");
Object.defineProperty(exports, "themes", { enumerable: true, get: function () { return lib_2.themes; } });
Object.defineProperty(exports, "Text", { enumerable: true, get: function () { return lib_2.Text; } });
__exportStar(require("@discord-card/core"), exports);
//# sourceMappingURL=index.js.map