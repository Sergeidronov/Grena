"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Text = exports.themes = exports.toImage = exports.getFontSize = exports.snap = exports.rootDir = void 0;
const canvas_1 = require("canvas");
const path_1 = require("path");
const fs_1 = require("fs");
const drawMultilineText = require("canvas-multiline-text");
//Path to the root directory of this package
exports.rootDir = (0, path_1.join)(__dirname, '..');
function path(...paths) {
    return (0, path_1.join)(exports.rootDir, ...paths);
}
// Snapshot system
const production = true;
var count = 0;
function snap(c) {
    if (!production)
        (0, fs_1.writeFileSync)(`./testing/snapshots/${count}.png`, c.toBuffer('image/png'));
    count++;
}
exports.snap = snap;
function getFontSize(str) {
    if (str.length < 18)
        return 30;
    return (600 * Math.pow(str.length, -1.05)).toFixed(0);
}
exports.getFontSize = getFontSize;
function toImage(image, name) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        if (image instanceof canvas_1.Canvas) {
            let img = new canvas_1.Image();
            img.src = image.toDataURL();
            return img;
        }
        else if (image instanceof canvas_1.Image)
            return image;
        else if (typeof image === 'string' || image instanceof Buffer)
            return yield (0, canvas_1.loadImage)(image);
        else
            throw new Error((_a = 'Invalid Image Format for: ' + name) !== null && _a !== void 0 ? _a : 'Image');
    });
}
exports.toImage = toImage;
exports.themes = {
    dark: { color: '#ffffff', image: path('images/dark.png') },
    circuit: { color: '#ffffff', image: path('images/circuit.png') },
    code: {
        color: '#ffffff',
        image: path('images/code.png'),
    },
};
class Text {
    constructor(text, posX, posY) {
        this.text = text;
        this.x = posX;
        this.y = posY;
        this.strokeOn = false;
    }
    setFont(font) {
        this.font = font;
        return this;
    }
    setFontSize(size) {
        this.fontSize = size;
        return this;
    }
    setStyle(style) {
        this.style = style;
        return this;
    }
    setGradient(gradient) {
        this.gradient = gradient;
        return this;
    }
    multiline(opts) {
        this.multilineOpts = opts !== null && opts !== void 0 ? opts : {};
        return this;
    }
    stroke(enabled) {
        this.strokeOn = enabled !== null && enabled !== void 0 ? enabled : true;
        return this;
    }
    draw(ctx, maxWidth) {
        var _a, _b;
        const before = JSON.parse(JSON.stringify({
            font: ctx.font,
            textAlign: ctx.textAlign,
            fillStyle: ctx.fillStyle,
            strokeStyle: ctx.strokeStyle,
        }));
        if (this.x < 1 && this.y < 1) {
            this.x *= ctx.canvas.width;
            this.y *= ctx.canvas.height;
        }
        if (this.textAlign)
            ctx.textAlign = this.textAlign;
        if (this.style) {
            ctx.fillStyle = this.style;
            ctx.strokeStyle = this.style;
        }
        if (this.gradient) {
            const grad = this.gradient.toString(ctx, this.x, this.y, maxWidth !== null && maxWidth !== void 0 ? maxWidth : ctx.w - this.x, ctx.h - this.y);
            ctx.fillStyle = grad;
            ctx.strokeStyle = grad;
        }
        if (this.font)
            ctx.changeFont(this.font);
        if (this.fontSize)
            ctx.changeFontSize(this.fontSize + 'px');
        let maxW = maxWidth !== null && maxWidth !== void 0 ? maxWidth : ctx.w - this.x;
        if (!!this.multilineOpts) {
            let w = (_a = this.multilineOpts.width) !== null && _a !== void 0 ? _a : ctx.canvas.width - this.x, h = (_b = this.multilineOpts.height) !== null && _b !== void 0 ? _b : ctx.canvas.height - this.y;
            const grad = this.gradient.toString(ctx, this.x, this.y, w, h);
            ctx.fillStyle = grad;
            ctx.strokeStyle = grad;
            drawMultilineText(ctx, this.text, {
                rect: {
                    x: this.x,
                    y: this.y,
                    width: w,
                    height: h,
                },
                //@ts-ignore
                stroke: this.strokeOn,
                lineHeight: this.multilineOpts.lineHeight,
                minFontSize: this.fontSize / 1.5 || undefined,
                maxFontSize: this.fontSize || undefined,
            });
        }
        else {
            if (this.strokeOn) {
                ctx.strokeText(this.text, this.x, this.y, maxW);
            }
            else
                ctx.fillText(this.text, this.x, this.y, maxW);
        }
        Object.assign(ctx, before);
    }
}
exports.Text = Text;
//# sourceMappingURL=lib.js.map