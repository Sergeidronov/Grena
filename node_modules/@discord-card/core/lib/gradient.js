"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConicGradient = exports.RadialGradient = exports.LinearGradient = exports.Gradient = void 0;
class Gradient {
    constructor(type, ...colors) {
        this.type = type;
        const arr = colors !== null && colors !== void 0 ? colors : [];
        this.colors = [];
        for (const stop of arr) {
            if (typeof stop['offset'] === 'number') {
                this.colors.push(stop);
            }
            else if (typeof stop['off'] === 'number') {
                this.colors.push({
                    offset: stop['off'],
                    color: stop['col'],
                });
            }
            else {
                this.colors.push({
                    offset: stop[0],
                    color: stop[1],
                });
            }
        }
    }
    addColorStop(offset, color) {
        this.colors.push({ offset, color });
    }
}
exports.Gradient = Gradient;
class LinearGradient extends Gradient {
    constructor(...colors) {
        super('linear', ...colors);
    }
    toString(ctx, xPos, yPos, width, height) {
        const cW = ctx.w, cH = ctx.h;
        let grad;
        if (xPos && yPos) {
            if (width && height) {
                grad = ctx.createLinearGradient(xPos, yPos, xPos + width, yPos + height);
            }
            else {
                grad = ctx.createLinearGradient(xPos, yPos, cW - xPos, cH - yPos);
            }
        }
        else {
            grad = ctx.createLinearGradient(0, 0, cW, cH);
        }
        for (const v of this.colors)
            grad.addColorStop(v.offset, v.color);
        return grad;
    }
}
exports.LinearGradient = LinearGradient;
class RadialGradient extends Gradient {
    constructor(...colors) {
        super('radial', ...colors);
    }
    toString(ctx, xPos, yPos, width, height) {
        const cW = ctx.w, cH = ctx.h;
        let radius;
        let grad;
        if (xPos && yPos) {
            if (width && height) {
                let x0 = xPos, y0 = yPos, r0, x1 = xPos + width, y1 = yPos + height, r1;
                if (width > height) {
                    r0 = r1 = height / 2;
                }
                else {
                    r0 = r1 = width / 2;
                }
                x0 += r0;
                y0 += r0;
                x1 -= r0;
                y1 -= r0;
                grad = ctx.createRadialGradient(x0, y0, r0, x1, y1, r1);
            }
            else {
                radius = ctx.h / 2;
                grad = ctx.createRadialGradient(xPos, yPos, radius, xPos, yPos, radius);
            }
        }
        else {
            grad = ctx.createRadialGradient(cW / 2, cH / 2, cW / 2, cW / 2, cH / 2, cW / 2);
        }
        for (const v of this.colors)
            grad.addColorStop(v.offset, v.color);
        return grad;
    }
}
exports.RadialGradient = RadialGradient;
class ConicGradient extends Gradient {
    constructor(...colors) {
        super('conic', ...colors);
    }
    toString(ctx, xPos, yPos, width, height) {
        let grad;
        if (xPos && yPos) {
            //@ts-ignore
            grad = ctx.createConicGradient(startAngle, xPos, yPos);
        }
        else {
            //@ts-ignore
            grad = ctx.createConicGradient(0, 0, 0);
        }
        for (const v of this.colors)
            grad.addColorStop(v.offset, v.color);
        return grad;
    }
}
exports.ConicGradient = ConicGradient;
//# sourceMappingURL=gradient.js.map